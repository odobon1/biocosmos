class_weighting:
  type:     inv_freq  # options: {null, inv_freq, class_balanced}
  if_gamma: 1.0  # (0.0, 1.0]; "inverse-frequency gamma", only used for type: inv_freq; 1 / n_c^(if_gamma); if_gamma = 1.0 --> 1 / n_c (classic scheme), if_gamma = 0.5 --> 1 / sqrt(n_c), if_gamma = 0.0 --> no weighting (uniform)
  cb_beta:  0.9999  # [0.0, 1.0); only used for type: class_balanced; controls aggressiveness
  cp_type:  2  # options: {1, 2}; class-pair computation type; 1: vanilla (i2t, t2i for same pair treated as separate "classes"), 2: negative pairs multiplied by 2, upper triangle extracted and used to normalize, full matrix constructed with normalized weights (i2t, t2i for same pair treated as same "classes")

focal:
  gamma:     2.0  # [0, inf); down-weights easy samples, larger gamma --> stronger focus on hard cases; 1-2 for softmax (InfoNCE), 2 for sigmoid; FL reduces to CE when gamma = 0
  comp_type: 2  # options: {1, 2}; continuous-form focal loss computation type; identical behavior to discrete form when targets=0/1

# only relevant for sigmoid (and maybe regression)
alpha_pos: 0.5  # [0, 1]; 0.5 equivalent to no pos/neg weighting; alpha_neg = 1 - alpha_pos
# alpha_pos: 0.9995117188  # (pairwise ratio for batch size = 2048) --- can get rid of this if it's not compatible with hierarchical
dyn_posneg: false  # dynamic reweighting of pos/neg; overrides alpha_pos; intended for use with multi-pos, also convenient for pairwise, not compatible with hierarchical

regression:
  temp:       false  # analog to CLIP + SigLIP temperature (scales logits)
  bias:       false  # analog to SigLIP bias (shifts logits)
  scale_type: 1  # options: {1, 2}; computation type used for scaling logits to range [0, 1]; type 1 uses an affine tranform, preceded by a tanh if temp and/or bias are used, type 2 uses a sigmoid
  huber_beta: 0.1